#!/usr/bin/env perl
use File::Basename;
use warnings;
use strict;
use Pod::Usage;
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure qw(gnu_getopt);
use IO::Uncompress::Gunzip qw(gunzip $GunzipError);

=pod

=head1 NAME

summary_mismatch.pl - Summarizes inferred error rate for AIMs

=head1 SYNOPSIS

summary_mismatch.pl [options] <barcode file> [min. AIMs to use tract]

 Positional arguments:
  <barcode file>       Barcode file from MSG
  [min. AIMs]          Cutoff for minimum length of tract to use
                       for error calculations

 Options:
  --help,-h,-?         Display this help documentation
  --scaffolds,-s       Scaffold(s) to use for error calculation
                       May be a comma-separated list
                       (default: all)

=head1 DESCRIPTION

summary_mismatch.pl uses counts of AIMs supporting the opposite ancestry
of the current tract (e.g. par1 if tract is par2/par2) to infer the
genotyping error rate (error_gamma).

=cut

my $help = 0;
my $man = 0;
my $scaffold_list = "";
my %scaffolds = ();
my $scaffold_specific = 0;
GetOptions('scaffolds|s=s' => \$scaffold_list, 'help|h|?' => \$help, man => \$man) or pod2usage(2);
pod2usage(-exitval => 1, -output => \*STDERR) if $help;
pod2usage(-exitval => 0, -output => \*STDERR, -verbose => 2) if $man;

#If the user wants to calculate the error rates for specific scaffold(s)
# we can subset these out of the sums below
if ($scaffold_list ne "") {
    $scaffold_specific = 1;
    my @scaffold_set = split /\s*,\s*/, $scaffold_list;
    for my $scaffold (@scaffold_set) {
        $scaffolds{$scaffold} = 1;
    }
}

my $src = dirname $0;
# generates a summary of *-matchMismatch.csv files generated by MSG
# uses the barcode file

# usage: perl summary_mismatch.pl barcodefile cutoff (optional minimum cutoff to assess error, default=0)
# perl summary_mismatch.pl yellow_barcode_all_nodups

my $outfh;
open $outfh, ">", "error_gamma";
print $outfh join("\t", "barcode", "gam_par1", "gam_par2"), "\n";

# read in the barcodes
my $barcodefile = shift(@ARGV);
chomp $barcodefile;
die "Barcode file ${barcodefile} does not exist!\n" unless -e $barcodefile;

my $cutoff = shift(@ARGV);
chomp $cutoff;

my $bcfh;
open $bcfh, "<", $barcodefile or die "wrong format for barcodefile\n";
my @barcodes = ();
while (my $barcodeline = <$bcfh>) {
    chomp $barcodeline; #Removes trailing newline
    $barcodeline =~ s/\r*//; #Removes any carriage returns, e.g. from Windows or Mac newlines
    my @rows = split /\s+/, $barcodeline; #Split the barcodes file on one or more whitespace characters (e.g. \t)
    my $barcodename = "indiv".$rows[1]."_".$rows[0];
    push(@barcodes, $barcodename);
}
close($bcfh);

# go through each barcode folder and generate an estimate of the error
for my $i (0..(scalar(@barcodes)-1)) {
    
    my $correct_par1_total = my $correct_par2_total = my $error_par1_total = my $error_par2_total =0;
    
    my $csvfile = "hmm_fit/" . $barcodes[$i] . "/" . $barcodes[$i] . "-matchMismatch.csv";
    unless (-e $csvfile) {
        warn "$csvfile not present. skipping\n";
        next;
    }
    system(qq{perl -p -i -e 's/\015/\n/go' $csvfile});
    system(qq{perl -p -i -e 's/\015\012/\n/go' $csvfile});
    my $csvfh;
    open $csvfh, "<", $csvfile or die "wrong path to csv? $csvfile \n";
    my $csvheader = <$csvfh>;
    my $j = 0;
    while (my $csvline = <$csvfh>){
        $j++;
        my @csvelems = split /,/, $csvline;
        if ($csvelems[0] =~ /par1/) {
            $correct_par1_total += $csvelems[5] unless $scaffold_specific and !exists($scaffolds{$csvelems[1]});
            $error_par1_total += $csvelems[6] unless $scaffold_specific and !exists($scaffolds{$csvelems[1]});
            if ($correct_par1_total > $cutoff) {
                print join("\t", $barcodes[$i], $j, "corr_par1:", $correct_par1_total, "error_par1:", $error_par1_total), "\n";
            }
        } elsif ($csvelems[0] =~ /par2/) {
            $correct_par2_total += $csvelems[6] unless $scaffold_specific and !exists($scaffolds{$csvelems[1]});
            $error_par2_total += $csvelems[5] unless $scaffold_specific and !exists($scaffolds{$csvelems[1]});
            if ($correct_par2_total > $cutoff) {
                print join("\t", $barcodes[$i], $j, "corr_par2:", $correct_par2_total, "error_par2:", $error_par2_total), "\n";
            }
        } else {
            die "neither par1 nor par2 " . $barcodes[$i] . " row $j\n";
        }
    }
    close($csvfh);
    my $error_par1 = "NA";
    if ($correct_par1_total > $cutoff) {
        $error_par1 = $error_par1_total / ($error_par1_total + $correct_par1_total);
    }
    my $error_par2 = "NA";
    if ($correct_par2_total > $cutoff) {
        $error_par2 = $error_par2_total / ($error_par2_total + $correct_par2_total);
    }
    print $outfh join("\t", $barcodes[$i], $error_par1, $error_par2), "\n";
}

system("R --no-save < $src/plot_error.R");
